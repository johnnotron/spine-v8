/*!
 * @pixi/spine-pixi - v2.1.0
 * Compiled Thu, 12 Sep 2024 09:57:37 UTC
 *
 * @pixi/spine-pixi is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2024, PixiJS Team, All Rights Reserved
 */import{Texture as te,ExtensionType as O,LoaderParserPriority as ne,checkExtension as W,DOMAdapter as re,path as V,TextureSource as se,extensions as Y,Geometry as xe,Buffer as oe,BufferUsage as I,Shader as ve,compileHighShaderGlProgram as ye,colorBitGl as ke,generateTextureBatchBitGl as Se,roundPixelsBitGl as Te,compileHighShaderGpuProgram as De,colorBit as Be,generateTextureBatchBit as Pe,roundPixelsBit as Ae,getBatchSamplersUniformGroup as Me,Batcher as Oe,collectAllRenderables as _e,ViewContainer as Le,Ticker as N,DEG_TO_RAD as je,Container as z,Cache as Q,Assets as ie,Graphics as B,Text as Fe}from"pixi.js";import{Texture as Ue,TextureFilter as T,TextureWrap as J,BlendMode as G,TextureAtlas as Re,SkeletonClipping as ae,RegionAttachment as L,MeshAttachment as X,Vector2 as We,Color as F,Skeleton as le,SkeletonData as de,AnimationState as Xe,AnimationStateData as Ee,Physics as $e,ClippingAttachment as ce,SkeletonBounds as he,AtlasAttachmentLoader as Ve,SkeletonBinary as Ye,SkeletonJson as Ie,PathAttachment as Ne}from"@esotericsoftware/spine-core";export*from"@esotericsoftware/spine-core";if(typeof window!="undefined"&&window.PIXI){const o=window.require;window.require=e=>{if(o)return o(e);if(e.startsWith("@pixi/")||e.startsWith("pixi.js"))return window.PIXI}}var ze=Object.defineProperty,Ge=(o,e,t)=>e in o?ze(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,ue=(o,e,t)=>(Ge(o,typeof e!="symbol"?e+"":e,t),t);const pe=class M extends Ue{constructor(e){super(e.resource),ue(this,"texture"),this.texture=te.from(e)}static from(e){return M.textureMap.has(e)?M.textureMap.get(e):new M(e)}setFilters(e,t){const r=this.texture.source.style;r.minFilter=M.toPixiTextureFilter(e),r.magFilter=M.toPixiTextureFilter(t),this.texture.source.autoGenerateMipmaps=M.toPixiMipMap(e),this.texture.source.updateMipmaps()}setWraps(e,t){const r=this.texture.source.style;r.addressModeU=M.toPixiTextureWrap(e),r.addressModeV=M.toPixiTextureWrap(t)}dispose(){this.texture.destroy()}static toPixiMipMap(e){switch(e){case T.Nearest:case T.Linear:return!1;case T.MipMapNearestLinear:case T.MipMapNearestNearest:case T.MipMapLinearLinear:case T.MipMapLinearNearest:return!0;default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiTextureFilter(e){switch(e){case T.Nearest:case T.MipMapNearestLinear:case T.MipMapNearestNearest:return"nearest";case T.Linear:case T.MipMapLinearLinear:case T.MipMapLinearNearest:return"linear";default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiTextureWrap(e){switch(e){case J.ClampToEdge:return"clamp-to-edge";case J.MirroredRepeat:return"mirror-repeat";case J.Repeat:return"repeat";default:throw new Error(`Unknown texture wrap: ${String(e)}`)}}static toPixiBlending(e){switch(e){case G.Normal:return"normal";case G.Additive:return"add";case G.Multiply:return"multiply";case G.Screen:return"screen";default:throw new Error(`Unknown blendMode: ${String(e)}`)}}};ue(pe,"textureMap",new Map);let K=pe;var He=Object.defineProperty,qe=Object.defineProperties,Qe=Object.getOwnPropertyDescriptors,ge=Object.getOwnPropertySymbols,Je=Object.prototype.hasOwnProperty,Ke=Object.prototype.propertyIsEnumerable,be=(o,e,t)=>e in o?He(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Ze=(o,e)=>{for(var t in e||(e={}))Je.call(e,t)&&be(o,t,e[t]);if(ge)for(var t of ge(e))Ke.call(e,t)&&be(o,t,e[t]);return o},et=(o,e)=>qe(o,Qe(e));const tt={extension:O.Asset,loader:{extension:{type:O.LoadParser,priority:ne.Normal,name:"spineTextureAtlasLoader"},test(o){return W(o,".atlas")},async load(o){return await(await re.get().fetch(o)).text()},testParse(o,e){const t=W(e.src,".atlas"),r=typeof o=="string";return Promise.resolve(t&&r)},unload(o){o.dispose()},async parse(o,e,t){const r=e.data||{};let n=V.dirname(e.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");const s=new Re(o);if(r.images instanceof se||typeof r.images=="string"){const i=r.images;r.images={},r.images[s.pages[0].name]=i}const a=[];for(const i of s.pages){const c=i.name,d=r!=null&&r.images?r.images[c]:void 0;if(d instanceof se)i.setTexture(K.from(d));else{const h={src:d!=null?d:V.normalize([...n.split(V.sep),c].join(V.sep)),data:et(Ze({},r.imageMetadata),{alphaMode:i.pma?"premultiplied-alpha":"premultiply-alpha-on-upload"})},l=t.load(h).then(p=>{i.setTexture(K.from(p.source))});a.push(l)}}return await Promise.all(a),s}}};Y.add(tt);function nt(o){return Object.prototype.hasOwnProperty.call(o,"bones")}function rt(o){return o instanceof Uint8Array}const st={extension:O.Asset,loader:{extension:{type:O.LoadParser,priority:ne.Normal,name:"spineSkeletonLoader"},test(o){return W(o,".skel")},async load(o){const e=await re.get().fetch(o);return new Uint8Array(await e.arrayBuffer())},testParse(o,e){const t=W(e.src,".json")&&nt(o),r=W(e.src,".skel")&&rt(o);return Promise.resolve(t||r)}}};Y.add(st);const ot=new Float32Array(1),it=new Uint32Array(1);class at extends xe{constructor(){const e=new oe({data:ot,label:"attribute-batch-buffer",usage:I.VERTEX|I.COPY_DST,shrinkToFit:!1}),t=new oe({data:it,label:"index-batch-buffer",usage:I.INDEX|I.COPY_DST,shrinkToFit:!1}),r=7*4;super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:r,offset:0},aUV:{buffer:e,format:"float32x2",stride:r,offset:2*4},aColor:{buffer:e,format:"unorm8x4",stride:r,offset:4*4},aDarkColor:{buffer:e,format:"unorm8x4",stride:r,offset:5*4},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:r,offset:6*4}},indexBuffer:t})}}const lt={name:"color-bit",vertex:{header:`
            @in aDarkColor: vec4<f32>;
            @out vDarkColor: vec4<f32>;
        `,main:`
        vDarkColor = aDarkColor;
        `},fragment:{header:`
            @in vDarkColor: vec4<f32>;
        `,end:`
            
        let alpha = outColor.a * vColor.a;
        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;

        finalColor = vec4<f32>(rgb, alpha);

        `}},dt={name:"color-bit",vertex:{header:`
            in vec4 aDarkColor;
            out vec4 vDarkColor;
        `,main:`
            vDarkColor = aDarkColor;
        `},fragment:{header:`
            in vec4 vDarkColor;
        `,end:`
            
        finalColor.a = outColor.a * vColor.a;
        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;
        `}};class ct extends ve{constructor(e){const t=ye({name:"dark-tint-batch",bits:[ke,dt,Se(e),Te]}),r=De({name:"dark-tint-batch",bits:[Be,lt,Pe(e),Ae]});super({glProgram:t,gpuProgram:r,resources:{batchSamplers:Me(e)}})}}var ht=Object.defineProperty,ut=(o,e,t)=>e in o?ht(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,E=(o,e,t)=>(ut(o,typeof e!="symbol"?e+"":e,t),t);let me=null;const fe=class we extends Oe{constructor(){super(...arguments),E(this,"geometry",new at),E(this,"shader",me||(me=new ct(this.maxTextures))),E(this,"name",we.extension.name),E(this,"vertexSize",7)}packAttributes(e,t,r,n,s){const a=s<<16|e.roundPixels&65535,i=e.transform,c=i.a,d=i.b,h=i.c,l=i.d,p=i.tx,f=i.ty,{positions:g,uvs:u}=e,b=e.color,m=e.darkColor,w=e.attributeOffset,x=w+e.attributeSize;for(let k=w;k<x;k++){const D=k*2,P=g[D],S=g[D+1];t[n++]=c*P+h*S+p,t[n++]=l*S+d*P+f,t[n++]=u[D],t[n++]=u[D+1],r[n++]=b,r[n++]=m,r[n++]=a}}packQuadAttributes(e,t,r,n,s){const a=e.texture,i=e.transform,c=i.a,d=i.b,h=i.c,l=i.d,p=i.tx,f=i.ty,g=e.bounds,u=g.maxX,b=g.minX,m=g.maxY,w=g.minY,x=a.uvs,k=e.color,D=e.darkColor,P=s<<16|e.roundPixels&65535;t[n+0]=c*b+h*w+p,t[n+1]=l*w+d*b+f,t[n+2]=x.x0,t[n+3]=x.y0,r[n+4]=k,r[n+5]=D,r[n+6]=P,t[n+7]=c*u+h*w+p,t[n+8]=l*w+d*u+f,t[n+9]=x.x1,t[n+10]=x.y1,r[n+11]=k,r[n+12]=D,r[n+13]=P,t[n+14]=c*u+h*m+p,t[n+15]=l*m+d*u+f,t[n+16]=x.x2,t[n+17]=x.y2,r[n+18]=k,r[n+19]=D,r[n+20]=P,t[n+21]=c*b+h*m+p,t[n+22]=l*m+d*b+f,t[n+23]=x.x3,t[n+24]=x.y3,r[n+25]=k,r[n+26]=D,r[n+27]=P}};E(fe,"extension",{type:[O.Batcher],name:"darkTint"});let pt=fe;Y.add(pt);var gt=Object.defineProperty,bt=(o,e,t)=>e in o?gt(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,v=(o,e,t)=>(bt(o,typeof e!="symbol"?e+"":e,t),t);class mt{constructor(){v(this,"indexOffset",0),v(this,"attributeOffset",0),v(this,"indexSize"),v(this,"attributeSize"),v(this,"batcherName","darkTint"),v(this,"packAsQuad",!1),v(this,"renderable"),v(this,"positions"),v(this,"indices"),v(this,"uvs"),v(this,"roundPixels"),v(this,"data"),v(this,"blendMode"),v(this,"darkTint"),v(this,"texture"),v(this,"transform"),v(this,"_textureId"),v(this,"_attributeStart"),v(this,"_indexStart"),v(this,"_batcher"),v(this,"_batch")}get color(){const e=this.data.color,t=this.renderable.groupColor,r=this.renderable.groupAlpha;let n;const s=e.a*r*255;if(t!==16777215){const a=t>>16&255,i=t>>8&255,c=t&255,d=e.r*c,h=e.g*i,l=e.b*a;n=s<<24|l<<16|h<<8|d}else n=s<<24|e.b*255<<16|e.g*255<<8|e.r*255;return n}get darkColor(){const e=this.data.darkColor;return e.a<<24|e.b*255<<16|e.g*255<<8|e.r*255}get groupTransform(){return this.renderable.groupTransform}setData(e,t,r,n,s){if(this.renderable=e,this.transform=e.groupTransform,this.data=t,t.clipped){const a=t.clippedData;this.indexSize=a.indicesCount,this.attributeSize=a.vertexCount,this.positions=a.vertices,this.indices=a.indices,this.uvs=a.uvs}else this.indexSize=t.indices.length,this.attributeSize=t.vertices.length/2,this.positions=t.vertices,this.indices=t.indices,this.uvs=t.uvs;this.texture=r,this.roundPixels=s,this.blendMode=n,this.batcherName=t.darkTint?"darkTint":"default"}}var ft=Object.defineProperty,wt=(o,e,t)=>e in o?ft(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Z=(o,e,t)=>(wt(o,typeof e!="symbol"?e+"":e,t),t);const Ct=new ae,xt={0:"normal",1:"add",2:"multiply",3:"screen"};class ee{constructor(e){Z(this,"renderer"),Z(this,"gpuSpineData",{}),this.renderer=e}validateRenderable(e){return e._applyState(),e.spineAttachmentsDirty}addRenderable(e,t){var r,n,s,a,i;const c=(r=this.gpuSpineData)[n=e.uid]||(r[n]={slotBatches:{}}),d=this.renderer.renderPipes.batch,h=e.skeleton.drawOrder,l=this.renderer._roundPixels|e._roundPixels;e._applyState();for(let p=0,f=h.length;p<f;p++){const g=h[p],u=g.getAttachment(),b=xt[g.data.blendMode];if(u instanceof L||u instanceof X){const w=e._getCachedData(g,u),x=(s=c.slotBatches)[a=w.id]||(s[a]=new mt);x.setData(e,w,((i=u.region)==null?void 0:i.texture.texture)||te.EMPTY,b,l),w.skipRender||d.addToBatch(x,t)}const m=e._slotsObject[g.data.name];if(m){const w=m.container;w.includeInBuild=!0,_e(w,t,this.renderer),w.includeInBuild=!1}}Ct.clipEnd()}updateRenderable(e){var t;const r=this.gpuSpineData[e.uid];e._applyState();const n=e.skeleton.drawOrder;for(let s=0,a=n.length;s<a;s++){const i=n[s],c=i.getAttachment();if((c instanceof L||c instanceof X)&&!e._getCachedData(i,c).skipRender){const d=r.slotBatches[e._getCachedData(i,c).id];(t=d._batcher)==null||t.updateElement(d)}}}destroyRenderable(e){this.gpuSpineData[e.uid]=null}destroy(){this.gpuSpineData=null,this.renderer=null}}Z(ee,"extension",{type:[O.WebGLPipes,O.WebGPUPipes,O.CanvasPipes],name:"spine"}),Y.add(ee);var vt=Object.defineProperty,yt=(o,e,t)=>e in o?vt(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,y=(o,e,t)=>(yt(o,typeof e!="symbol"?e+"":e,t),t);const H=new We,kt=new F,St=new F;le.yDown=!0;const U=new ae;class q extends Le{constructor(e){var t;e instanceof de&&(e={skeletonData:e}),super(),y(this,"batched",!0),y(this,"buildId",0),y(this,"renderPipeId","spine"),y(this,"_didSpineUpdate",!1),y(this,"beforeUpdateWorldTransforms",()=>{}),y(this,"afterUpdateWorldTransforms",()=>{}),y(this,"skeleton"),y(this,"state"),y(this,"skeletonBounds"),y(this,"_debug"),y(this,"_slotsObject",Object.create(null)),y(this,"spineAttachmentsDirty"),y(this,"_lastAttachments"),y(this,"_stateChanged"),y(this,"attachmentCacheData",[]),y(this,"autoUpdateWarned",!1),y(this,"_autoUpdate",!0);const r=e instanceof de?e:e.skeletonData;this.skeleton=new le(r),this.state=new Xe(new Ee(r)),this.autoUpdate=(t=e==null?void 0:e.autoUpdate)!=null?t:!0;const n=this.skeleton.slots;for(let s=0;s<n.length;s++)this.attachmentCacheData[s]=Object.create(null);this._updateState(0)}getSlotFromRef(e){let t;if(typeof e=="number"?t=this.skeleton.slots[e]:typeof e=="string"?t=this.skeleton.findSlot(e):t=e,!t)throw new Error(`No slot found with the given slot reference: ${e}`);return t}get debug(){return this._debug}set debug(e){this._debug&&this._debug.unregisterSpine(this),e&&e.registerSpine(this),this._debug=e}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e?(N.shared.add(this.internalUpdate,this),this.autoUpdateWarned=!1):N.shared.remove(this.internalUpdate,this),this._autoUpdate=e}update(e){this.autoUpdate&&!this.autoUpdateWarned&&(console.warn("You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want."),this.autoUpdateWarned=!0),this.internalUpdate(0,e)}internalUpdate(e,t){this._updateState(t!=null?t:N.shared.deltaMS/1e3)}get bounds(){return this._boundsDirty&&this.updateBounds(),this._bounds}setBonePosition(e,t){const r=e;if(typeof e=="string"&&(e=this.skeleton.findBone(e)),!e)throw Error(`Cant set bone position, bone ${String(r)} not found`);if(H.set(t.x,t.y),e.parent){const n=e.parent.worldToLocal(H);e.x=n.x,e.y=-n.y}else e.x=H.x,e.y=H.y}getBonePosition(e,t){const r=e;return typeof e=="string"&&(e=this.skeleton.findBone(e)),e?(t||(t={x:0,y:0}),t.x=e.worldX,t.y=e.worldY,t):(console.error(`Cant set bone position! Bone ${String(r)} not found`),t)}_updateState(e){this.state.update(e),this.skeleton.update(e),this._stateChanged=!0,this._boundsDirty=!0,this.onViewUpdate()}_applyState(){if(!this._stateChanged)return;this._stateChanged=!1;const{skeleton:e}=this;this.state.apply(e),this.beforeUpdateWorldTransforms(this),e.updateWorldTransform($e.update),this.afterUpdateWorldTransforms(this),this.validateAttachments(),this.transformAttachments(),this.updateSlotObjects()}validateAttachments(){const e=this.skeleton.drawOrder,t=this._lastAttachments||(this._lastAttachments=[]);let r=0,n=!1;for(let s=0;s<e.length;s++){const a=e[s].getAttachment();a&&(a!==t[r]&&(n=!0,t[r]=a),r++)}r!==t.length&&(n=!0,t.length=r),this.spineAttachmentsDirty=n}transformAttachments(){const e=this.skeleton.drawOrder;for(let t=0;t<e.length;t++){const r=e[t],n=r.getAttachment();if(n){if(n instanceof X||n instanceof L){const s=this._getCachedData(r,n);n instanceof L?n.computeWorldVertices(r,s.vertices,0,2):n.computeWorldVertices(r,0,n.worldVerticesLength,s.vertices,0,2),s.uvs=n.uvs;const a=r.bone.skeleton.color,i=r.color,c=n.color;s.color.set(a.r*i.r*c.r,a.g*i.g*c.g,a.b*i.b*c.b,a.a*i.a*c.a),s.darkTint=!!r.darkColor,r.darkColor&&s.darkColor.setFromColor(r.darkColor),s.skipRender=s.clipped=!1,U.isClipping()&&this.updateClippingData(s)}else if(n instanceof ce){U.clipStart(r,n);continue}}U.clipEndWithSlot(r)}U.clipEnd()}updateClippingData(e){e.clipped=!0,U.clipTriangles(e.vertices,e.vertices.length,e.indices,e.indices.length,e.uvs,kt,St,!1);const{clippedVertices:t,clippedTriangles:r}=U,n=t.length/8,s=r.length;e.clippedData||(e.clippedData={vertices:new Float32Array(n*2),uvs:new Float32Array(n*2),vertexCount:n,indices:new Uint16Array(s),indicesCount:s},this.spineAttachmentsDirty=!0);const a=e.clippedData,i=a.vertexCount!==n||s!==a.indicesCount;e.skipRender=n===0,i&&(this.spineAttachmentsDirty=!0,a.vertexCount<n&&(a.vertices=new Float32Array(n*2),a.uvs=new Float32Array(n*2)),a.indices.length<s&&(a.indices=new Uint16Array(s)));const{vertices:c,uvs:d,indices:h}=a;for(let l=0;l<n;l++)c[l*2]=t[l*8],c[l*2+1]=t[l*8+1],d[l*2]=t[l*8+6],d[l*2+1]=t[l*8+7];a.vertexCount=n;for(let l=0;l<h.length;l++)h[l]=r[l];a.indicesCount=s}updateSlotObjects(){for(const e in this._slotsObject){const t=this._slotsObject[e];t&&this.updateSlotObject(t)}}updateSlotObject(e){const{slot:t,container:r}=e;if(r.visible=this.skeleton.drawOrder.includes(t),r.visible){const n=t.bone;r.position.set(n.worldX,n.worldY),r.scale.x=n.getWorldScaleX(),r.scale.y=n.getWorldScaleY(),r.rotation=n.getWorldRotationX()*je}}_getCachedData(e,t){return this.attachmentCacheData[e.data.index][t.name]||this.initCachedData(e,t)}initCachedData(e,t){let r;return t instanceof L?(r=new Float32Array(8),this.attachmentCacheData[e.data.index][t.name]={id:`${e.data.index}-${t.name}`,vertices:r,clipped:!1,indices:[0,1,2,0,2,3],uvs:t.uvs,color:new F(1,1,1,1),darkColor:new F(0,0,0,0),darkTint:!1,skipRender:!1}):(r=new Float32Array(t.worldVerticesLength),this.attachmentCacheData[e.data.index][t.name]={id:`${e.data.index}-${t.name}`,vertices:r,clipped:!1,indices:t.triangles,uvs:t.uvs,color:new F(1,1,1,1),darkColor:new F(0,0,0,0),darkTint:!1,skipRender:!1}),this.attachmentCacheData[e.data.index][t.name]}onViewUpdate(){var e;if(this._didChangeId+=4096,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this),(e=this.debug)==null||e.renderDebug(this)}addSlotObject(e,t){var r;e=this.getSlotFromRef(e);for(const n in this._slotsObject)((r=this._slotsObject[n])==null?void 0:r.container)===t&&this.removeSlotObject(this._slotsObject[n].slot);this.removeSlotObject(e),t.includeInBuild=!1,this.addChild(t),this._slotsObject[e.data.name]={container:t,slot:e},this.updateSlotObject(this._slotsObject[e.data.name])}removeSlotObject(e){var t,r;let n;if(e instanceof z){for(const s in this._slotsObject)if(((t=this._slotsObject[s])==null?void 0:t.container)===e){this._slotsObject[s]=null,n=e;break}}else{const s=this.getSlotFromRef(e);n=(r=this._slotsObject[s.data.name])==null?void 0:r.container,this._slotsObject[s.data.name]=null}n&&(this.removeChild(n),n.includeInBuild=!0)}getSlotObject(e){return e=this.getSlotFromRef(e),this._slotsObject[e.data.name].container}updateBounds(){this._boundsDirty=!1,this.skeletonBounds||(this.skeletonBounds=new he);const e=this.skeletonBounds;if(e.update(this.skeleton,!0),e.minX===1/0){this._applyState();const t=this.skeleton.drawOrder,r=this._bounds;r.clear();for(let n=0;n<t.length;n++){const s=t[n],a=s.getAttachment();if(a&&(a instanceof L||a instanceof X)){const i=this._getCachedData(s,a);r.addVertexData(i.vertices,0,i.vertices.length)}}}else this._bounds.minX=e.minX,this._bounds.minY=e.minY,this._bounds.maxX=e.maxX,this._bounds.maxY=e.maxY}addBounds(e){e.addBounds(this.bounds)}destroy(e=!1){super.destroy(e),N.shared.remove(this.internalUpdate,this),this.state.clearListeners(),this.debug=void 0,this.skeleton=null,this.state=null,this._slotsObject=null,this._lastAttachments=null,this.attachmentCacheData=null}skeletonToPixiWorldCoordinates(e){this.worldTransform.apply(e,e)}pixiWorldCoordinatesToSkeleton(e){this.worldTransform.applyInverse(e,e)}pixiWorldCoordinatesToBone(e,t){this.pixiWorldCoordinatesToSkeleton(e),t.parent?t.parent.worldToLocal(e):t.worldToLocal(e)}static from({skeleton:e,atlas:t,scale:r=1}){const n=`${e}-${t}-${r}`;if(Q.has(n))return new q(Q.get(n));const s=ie.get(e),a=ie.get(t),i=new Ve(a),c=s instanceof Uint8Array?new Ye(i):new Ie(i);c.scale=r;const d=c.readSkeletonData(s);return Q.set(n,d),new q({skeletonData:d})}}var Tt=Object.defineProperty,Dt=(o,e,t)=>e in o?Tt(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,C=(o,e,t)=>(Dt(o,typeof e!="symbol"?e+"":e,t),t);class Bt{constructor(){C(this,"registeredSpines",new Map),C(this,"drawMeshHull",!0),C(this,"drawMeshTriangles",!0),C(this,"drawBones",!0),C(this,"drawPaths",!0),C(this,"drawBoundingBoxes",!0),C(this,"drawClipping",!0),C(this,"drawRegionAttachments",!0),C(this,"drawEvents",!0),C(this,"lineWidth",1),C(this,"regionAttachmentsColor",30975),C(this,"meshHullColor",30975),C(this,"meshTrianglesColor",16763904),C(this,"clippingPolygonColor",16711935),C(this,"boundingBoxesRectColor",65280),C(this,"boundingBoxesPolygonColor",65280),C(this,"boundingBoxesCircleColor",65280),C(this,"pathsCurveColor",16711680),C(this,"pathsLineColor",16711935),C(this,"skeletonXYColor",16711680),C(this,"bonesColor",61132),C(this,"eventFontSize",24),C(this,"eventFontColor",0)}registerSpine(e){if(this.registeredSpines.has(e)){console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",e);return}const t={parentDebugContainer:new z,bones:new z,skeletonXY:new B,regionAttachmentsShape:new B,meshTrianglesLine:new B,meshHullLine:new B,clippingPolygon:new B,boundingBoxesRect:new B,boundingBoxesCircle:new B,boundingBoxesPolygon:new B,pathsCurve:new B,pathsLine:new B,eventText:new z,eventCallback:{event:(r,n)=>{if(this.drawEvents){const s=Math.abs(e.scale.x||e.scale.y||1),a=new Fe({text:n.data.name,style:{fontSize:this.eventFontSize/s,fill:this.eventFontColor,fontFamily:"monospace"}});a.scale.x=Math.sign(e.scale.x),a.anchor.set(.5),t.eventText.addChild(a),setTimeout(()=>{a.destroyed||a.destroy()},250)}}}};t.parentDebugContainer.addChild(t.bones),t.parentDebugContainer.addChild(t.skeletonXY),t.parentDebugContainer.addChild(t.regionAttachmentsShape),t.parentDebugContainer.addChild(t.meshTrianglesLine),t.parentDebugContainer.addChild(t.meshHullLine),t.parentDebugContainer.addChild(t.clippingPolygon),t.parentDebugContainer.addChild(t.boundingBoxesRect),t.parentDebugContainer.addChild(t.boundingBoxesCircle),t.parentDebugContainer.addChild(t.boundingBoxesPolygon),t.parentDebugContainer.addChild(t.pathsCurve),t.parentDebugContainer.addChild(t.pathsLine),t.parentDebugContainer.addChild(t.eventText),t.parentDebugContainer.zIndex=9999999,t.parentDebugContainer.accessibleChildren=!1,t.parentDebugContainer.eventMode="none",t.parentDebugContainer.interactiveChildren=!1,e.addChild(t.parentDebugContainer),e.state.addListener(t.eventCallback),this.registeredSpines.set(e,t)}renderDebug(e){this.registeredSpines.has(e)||this.registerSpine(e);const t=this.registeredSpines.get(e);if(!t)return;e.addChild(t.parentDebugContainer),t.skeletonXY.clear(),t.regionAttachmentsShape.clear(),t.meshTrianglesLine.clear(),t.meshHullLine.clear(),t.clippingPolygon.clear(),t.boundingBoxesRect.clear(),t.boundingBoxesCircle.clear(),t.boundingBoxesPolygon.clear(),t.pathsCurve.clear(),t.pathsLine.clear();for(let s=t.bones.children.length;s>0;s--)t.bones.children[s-1].destroy({children:!0,texture:!0,textureSource:!0});const r=Math.abs(e.scale.x||e.scale.y||1),n=this.lineWidth/r;if(this.drawBones&&this.drawBonesFunc(e,t,n,r),this.drawPaths&&this.drawPathsFunc(e,t,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(e,t,n),this.drawClipping&&this.drawClippingFunc(e,t,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(e,t,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(e,t,n),this.drawEvents)for(const s of t.eventText.children)s.alpha-=.05,s.y-=2}drawBonesFunc(e,t,r,n){const s=e.skeleton,a=s.x,i=s.y,c=s.bones;t.skeletonXY.strokeStyle={width:r,color:this.skeletonXYColor};for(let h=0,l=c.length;h<l;h++){const p=c[h],f=p.data.length,g=a+p.worldX,u=i+p.worldY,b=a+f*p.a+p.worldX,m=i+f*p.b+p.worldY;if(p.data.name==="root"||p.data.parent===null)continue;const w=Math.abs(g-b),x=Math.abs(u-m),k=Math.pow(w,2),D=x,P=Math.pow(x,2),S=Math.sqrt(k+P),Ce=Math.pow(S,2),R=Math.PI/180,$=Math.acos((Ce+P-k)/(2*D*S))||0;if(S===0)continue;const _=new B;t.bones.addChild(_);const j=S/50/n;_.context.poly([0,0,0-j,S-j*3,0,S-j,0+j,S-j*3]).fill(this.bonesColor),_.x=g,_.y=u,_.pivot.y=S;let A=0;g<b&&u<m?A=-$+180*R:g>b&&u<m?A=180*(R+$):g>b&&u>m?A=-$:g<b&&u>m?A=$:u===m&&g<b?A=90*R:u===m&&g>b?A=-90*R:g===b&&u<m?A=180*R:g===b&&u>m&&(A=0),_.rotation=A,_.circle(0,S,j*1.2).fill({color:0,alpha:.6}).stroke({width:r,color:this.skeletonXYColor})}const d=r*3;t.skeletonXY.context.moveTo(a-d,i-d).lineTo(a+d,i+d).moveTo(a+d,i-d).lineTo(a-d,i+d).stroke()}drawRegionAttachmentsFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const i=n[s],c=i.getAttachment();if(c===null||!(c instanceof L))continue;const d=c,h=new Float32Array(8);d.computeWorldVertices(i,h,0,2),t.regionAttachmentsShape.poly(Array.from(h.slice(0,8)))}t.regionAttachmentsShape.stroke({color:this.regionAttachmentsColor,width:r})}drawMeshHullAndMeshTriangles(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const i=n[s];if(!i.bone.active)continue;const c=i.getAttachment();if(c===null||!(c instanceof X))continue;const d=c,h=new Float32Array(d.worldVerticesLength),l=d.triangles;let p=d.hullLength;if(d.computeWorldVertices(i,0,d.worldVerticesLength,h,0,2),this.drawMeshTriangles)for(let f=0,g=l.length;f<g;f+=3){const u=l[f]*2,b=l[f+1]*2,m=l[f+2]*2;t.meshTrianglesLine.context.moveTo(h[u],h[u+1]).lineTo(h[b],h[b+1]).lineTo(h[m],h[m+1])}if(this.drawMeshHull&&p>0){p=(p>>1)*2;let f=h[p-2],g=h[p-1];for(let u=0,b=p;u<b;u+=2){const m=h[u],w=h[u+1];t.meshHullLine.context.moveTo(m,w).lineTo(f,g),f=m,g=w}}}t.meshHullLine.stroke({width:r,color:this.meshHullColor}),t.meshTrianglesLine.stroke({width:r,color:this.meshTrianglesColor})}drawClippingFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const i=n[s];if(!i.bone.active)continue;const c=i.getAttachment();if(c===null||!(c instanceof ce))continue;const d=c,h=d.worldVerticesLength,l=new Float32Array(h);d.computeWorldVertices(i,0,h,l,0,2),t.clippingPolygon.poly(Array.from(l))}t.clippingPolygon.stroke({width:r,color:this.clippingPolygonColor,alpha:1})}drawBoundingBoxesFunc(e,t,r){t.boundingBoxesRect.lineStyle(r,this.boundingBoxesRectColor,5);const n=new he;n.update(e.skeleton,!0),t.boundingBoxesRect.rect(n.minX,n.minY,n.getWidth(),n.getHeight()).stroke({width:r,color:this.boundingBoxesRectColor});const s=n.polygons,a=(i,c,d)=>{if(d<3)throw new Error("Polygon must contain at least 3 vertices");const h=[],l=r*2;for(let p=0,f=i.length;p<f;p+=2){const g=i[p],u=i[p+1];t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),t.boundingBoxesCircle.drawCircle(g,u,l),t.boundingBoxesCircle.fill(0),h.push(g,u)}t.boundingBoxesPolygon.poly(h).fill({color:this.boundingBoxesPolygonColor,alpha:.1}).stroke({width:r,color:this.boundingBoxesPolygonColor})};for(let i=0,c=s.length;i<c;i++){const d=s[i];a(d,0,d.length)}}drawPathsFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const i=n[s];if(!i.bone.active)continue;const c=i.getAttachment();if(c===null||!(c instanceof Ne))continue;const d=c;let h=d.worldVerticesLength;const l=new Float32Array(h);d.computeWorldVertices(i,0,h,l,0,2);let p=l[2],f=l[3],g=0,u=0;if(d.closed){const b=l[0],m=l[1],w=l[h-2],x=l[h-1];g=l[h-4],u=l[h-3],t.pathsCurve.moveTo(p,f),t.pathsCurve.bezierCurveTo(b,m,w,x,g,u),t.pathsLine.moveTo(p,f),t.pathsLine.lineTo(b,m),t.pathsLine.moveTo(g,u),t.pathsLine.lineTo(w,x)}h-=4;for(let b=4;b<h;b+=6){const m=l[b],w=l[b+1],x=l[b+2],k=l[b+3];g=l[b+4],u=l[b+5],t.pathsCurve.moveTo(p,f),t.pathsCurve.bezierCurveTo(m,w,x,k,g,u),t.pathsLine.moveTo(p,f),t.pathsLine.lineTo(m,w),t.pathsLine.moveTo(g,u),t.pathsLine.lineTo(x,k),p=g,f=u}}t.pathsCurve.stroke({width:r,color:this.pathsCurveColor}),t.pathsLine.stroke({width:r,color:this.pathsLineColor})}unregisterSpine(e){this.registeredSpines.has(e)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",e);const t=this.registeredSpines.get(e);t&&(e.state.removeListener(t.eventCallback),t.parentDebugContainer.destroy({textureSource:!0,children:!0,texture:!0}),this.registeredSpines.delete(e))}}export{q as Spine,Bt as SpineDebugRenderer,ee as SpinePipe,K as SpineTexture};
//# sourceMappingURL=pixi-spine-pixi.mjs.map
